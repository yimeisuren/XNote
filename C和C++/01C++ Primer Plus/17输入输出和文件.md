# 输入输出和文件

## 输入输出概述

### 流和缓冲区

C++程序把输入输出看作是字节流.

输入时, 程序从输入流中抽取字节; 输出时, 程序将字节插入到输出流中. 对于面向文本的程序, 每个字节代表一个字符.

输入流中的字节可能来自键盘, 也可能来自存储设备或其它程序; 同样输出流可以流向屏幕, 打印机, 存储设备或其它程序.

![](https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E6%B5%81%E4%B8%8E%E7%A8%8B%E5%BA%8F.svg)

流这种桥梁的存在使得C++程序可以*以相同的方式对待来自键盘的输入和来自文件的输入*, C++程序只需要检查字节流而不需要直到字节流来自何处. 输出同理. 
因此管理输入输出包含两步:

1. 将流与输入去向的程序关联起来
2. 将流与文件连接起来

通常会使用缓冲区来帮助更高效地处理输入和输出. 缓冲区和磁盘之间以512B(或更多)为一个块进行数据交换, 而程序通常每次只能处理1B的信息, 缓冲区能帮助匹配这两种不同的信息传输速率. 
输出时, 程序首先填满缓冲区, 然后*把整块数据传输给硬盘, 并清空缓冲区*, 以备下一批输出使用, 这被称为*刷新缓冲区flush the buffer*

假设没有缓冲区, 程序要读取512B信息, 就要执行512次读磁盘操作(每次读取1B), 而读磁盘操作是非常耗费时间的, 而使用缓冲区方式只需要1次读磁盘操作和512次读内存操作即可. 

对于*键盘输入*, 由于每次提供一个字符, 因此在这种情况下是*可以不使用缓冲区*的, 但是这样*用户就无法对输入数据进行修改*, 每次输入数据都会被立即送入程序, 而使用缓冲区可以在用户按下回车的时候刷新输入缓冲区

### 流, 缓冲区和iostream文件

管理流和缓冲区的工作有些复杂, 在`iostream`头文件中包含一些专门设计用来实现管理流和缓冲区的类.

![](https://namebucket.oss-cn-beijing.aliyuncs.com/img/IO%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.svg)

*streambuf类*: 为缓冲区提供了内存, 并提供了用于填充缓冲区, 访问缓冲区内容, 刷新缓冲区和管理缓冲区内存的类方法

*ios_base类*: 表示流的一般特征, 如是否可读取, 是二进制流还是文本流等

*ios类*: 基于ios_base类, 其中包括了一个指向streambuf类对象的指针成员

*istream类*: 由ios类派生而来, 提供了输入方法

*ostream类*: 由ios类派生而来, 提供了输出方法

*iostream类*: 由istream类和ostream类派生而来, 继承了输入输出方法

在程序中包含iostream头文件将*自动创建8个流对象*, 分别是cin, cout, cerr, clog和wcin, wcout, wcerr, wclog

*对象代表流*: 当自动创建一个cout对象时, 该对象间包含存储了与输出有关的信息的数据成员, 如显示数据时使用的字段宽度, 小数位数, 显示整数时采用的计数方法以及描述用来处理输出流的缓冲区的streambuf对象的地址*(简单来说, 就是cout对象中不仅包含输出数据, 还包含输出格式控制方式等)*

| 流对象 | 功能                                                         |
| ------ | ------------------------------------------------------------ |
| `cin`  | 对应*标准输入流*, 默认情况下关联标准输入设备(键盘)           |
| `cout` | 对应*标准输出流*, 默认情况下关联到标准输出设备(显示器)       |
| `cerr` | 对应*标准错误流*, 可用于显示错误消息<br />这个流没有缓冲区, 意味着会被立即显示到屏幕上, 而不需要回车刷新 |
| `clog` | 对应*标准错误流*<br />这个流会被缓冲                         |

### 重定向

标准输入和输出流通常连接着键盘和屏幕, 但很多操作系统都支持*重定向*, 可以改变标准输入和标准输出.

以Windows系统中的cmd为例. 重定向来自操作系统, 而不是C++.

1. 假设有一个源程序`counter.exe`, 功能用来统计输入字符中各个字符出现的次数并输出

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   
   int main(){
       string s;
       vector<int> counts(26);
       
       cin >> s;
   
       for (char ch : s){
           counts[ch - 'a']++;
       }
   
       for (int i = 0; i < 26; i++){
           cout << char('a' + i) << " : " << counts[i] << endl;
       }
       return 0;
   }
   ```
   
   
   
2. 编译后生成`counter.exe`程序, 使用cmd窗口测试重定向功能

3. 直接运行程序的结果
   ![image-20220222152106037](https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E9%87%8D%E5%AE%9A%E5%90%91%E6%B5%8B%E8%AF%95_%E5%89%8D.png)

4. 使用重定向功能`程序名 <输入文件名  >输出文件名`

   ![image-20220222152243185](https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E6%B5%8B%E8%AF%95%E9%87%8D%E5%AE%9A%E5%90%91%E5%8A%9F%E8%83%BD_%E5%90%8E.png)

   输出结果会放入output.txt文件中, 如下所示

   <img src="https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E6%B5%8B%E8%AF%95%E9%87%8D%E5%AE%9A%E5%90%91%E5%8A%9F%E8%83%BD_%E5%90%8E_%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6.png" alt="image-20220222152418727"  />

对标准输出流的重定向不会影响cerr和clog, 因此当cout被重定向到屏幕之外的源目标时, 使用cerr来输出错误信息. 例如下列部分代码

```c++
freopen("output.txt", "w", stdout);		//输出重定向
if(condition){
    cout << "success" << endl;//success被写入到output.txt文件中
}else{
    cerr << "some errors have happened" << endl;//显示到屏幕上
}
```

## 使用cout进行输出

C++将输出看作是字节流, 根据实现和平台的不同, 字节可能是8bit, 16bit, 32bit. 在程序中很多数据类型的长度比字节更大, 例如int类型为16bit或32bit, double为64bit. 

在将字节流发送给屏幕时, 希望每个字节表示一个字符, 也就是说要在屏幕上显示数字-2.34, 需要将5个字符`-`, `2`, `.`, `3`, `4`发送到屏幕上, 而不是-2.34的64位内部浮点表示. 因此ostream类最重要的任务是*将数值类型转换为以文本形式表示的字符流*, 即将二进制位模式转换为由字符字节组成的输出流

### 重载的`<<`运算符

#### 输出和指针

`<<`运算符的默认含义是按位左移
在ostream类中重载了`<<`表示输出, 可以识别C++中*所有的基本类型, 字符指针`char *`和空指针`void*`*

```c++
char name[20] = "hello world";
char *pn = "HELLO WORLD";
cout << "Hello World";		//字符串常量
cout << name;				//字符数组名
cout << pn;					//字符指针
```

`<<`操作会根据字符串末尾的空字符`\0`来作为输出结束的标志

对于其它类型的指针, `<<`将其看作是`void*`类型, 输出指针的值(即地址). 如果想要获取字符串的地址, 必须将其强制转换为其它类型

```c++
char *pn = "hello world";
cout << pn << endl;			//输出字符串
cout << (void*)pn << endl;	//输出字符串的地址
```

#### 链式调用

`<<`运算符的所有返回值的返回类型都是`ostream &` 

例如`cout << 8`表示显示8的值, 然后返回cout对象

### 其它输出方法

除了`>>`作为输出之外, ostream类还提供了`put()`方法和`write()`方法, 前者用来显示字符, 后者用来显示字符串. 返回类型都是`ostream &`

```c++
char *pn = "hello world";
cout.put('H').put('e').put('l').put('l').put('o');
cout.write(pn, 10);//首地址 + 字符个数
```

`write()`方法并不会在遇到空字符的时候结束输出, 会完完整整的输出10个字符, 即使会越界

```c++
int val = 0x44434241;			//val在内存中的16进制存储(小端存储): 41 42 43 44
cout.write((char*)&val, sizeof(int))<<endl;//char*表示将数据解释为字符, 按字符规则输出A B C D
```

### 刷新输出缓冲区

如果程序使用cout将字节发送给标准输出, 由于ostream类对cout对象处理的输出进行缓冲, 所以输出不会立即发送到目标地址, 而是被*存储在缓冲区中, 直到缓冲区被填满, 然后程序将刷新缓冲区, 将内容发送出去*, 并清空缓冲区

对于*屏幕输出而言, 没必要填满缓冲区*, 当遇到`flush或endl`的时候或即将发生输入的时候, 将会刷新缓冲区

### 用cout进行格式化控制

在`iomanip`头文件中有常用的格式控制符

`setprecision()`: 控制精度
`setfill()`: 填充字符
`setw()`: 设置宽度

## 使用cin进行输入

### `>>`运算符如何检查输入

所有版本的`>>`运算符都遵循相同的规则: *跳过空白字符(空格, 换行, 制表符), 直到遇到非空白字符*, 即只读取非空白字符

#### `>>`运算符只会读取符合数据类型的*有效字符*

```c++
int x;
char ch;
cin >> x;			//假设输入-123H, 则x = -123, 其中H会被留在输入流中
cin >> ch;			//不需要进行输入, 直接赋值ch = 'H', 即使换成string s也会导致s = "H"
```

如果输入流中没有一个有效字符, `>>`运算符会返回0*(表示出错或者到达文件尾)*

```c++
//验证
int val;
while(cin >> val){	//如果cin>>val的返回值不为0, 则陷入死循环,程序无法正常结束
}					//分别尝试输入25和Zeal,观察结果
return 0;
```

*当流状态出现异常的时候会返回true, 表示某种错误或者到达文件尾*

### 流状态

cin和cout对象中有一个成员变量iostate用来描述流的状态, iostate类似标志寄存器, 通过其中的不同位表示不同含义

<img src="https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E6%B5%81%E7%8A%B6%E6%80%81iostate.svg" style="zoom:25%;" />

当到达文件尾的时候会将eofbit设置为1, 而当出现上述的无法读取有效字符时, 会将failbit设置为1, 而正常状态则是全为0

#### 设置状态

`clear()`方法在设置某个状态位的时候会清除其它状态位

`setstate()`方法只影响设置的位

```c++
clear(eofbit);				//将流状态设置为eofbit, 而badbit和failbit会被重置为0
clear();					//所有状态位被重置为0
setstate(eofbit);			//只将eofbit为设置为1, 其它位保持不变
```

#### I/O和异常













### 其它输入方法

`get()`方法和`getline()`方法不会跳过空白字符, 也不会进行类型转换, 只是将

```c++
const int CAPACITY = 20;
char ch;
int x;
char chs[CAPACITY];		//字符数组
string s;				//string类

//单个字符
cin.get(ch);				//读取一个字符, 为ch赋值, 会读取空白字符
x = cin.get();				//读取一个字符, 将输入字符的ASCII码值返回

//单行字符
getline(cin, s);			//该getline()不是istream中的方法, cin在这表示标准输入, 即键盘
cin.getline(chs, CAPACITY+1, '\0');	//读取一行,会读取空白字符, 将前CAPACITY个字符为chs数组赋值
cin.get(chs, CAPACITY+1, '\0');		//用法和cin.getline()基本一样
```

`cin.get()`和`cin.getline()`之间的区别*(第三个参数是指定分界符)*

+ `get()`会将末尾的分界符*保留*在输入流中
+ `getline()`则会将末尾的分界符从输入流中提取并*丢弃*

默认分界符为`\n`, 也就是代表一行的结束, 如果指定`\0`为分界符, 则会认为整篇文章都是*一行*

## 文件输入和输出

重定向可以实现文件的输入和输出, 但是存在局限性

使用C++ I/O类软件包处理文件时, 要写入文件, 需要创建一个ofstream对象; 要读取文件, 需要创建一个ifstream对象. 
与标准输入输出相比, 文件管理更为复杂, 必须将新打开的文件和流关联起来, 可以以只读模式, 只写模式或读写模式打开文件, 写文件时, 可能创建新文件, 取代旧文件或追加到文件中, 还可能想在文件中来回移动

### 简单的文件I/O

#### 文件模式

文件模式描述的是文件将被如何使用: 读, 写, 追加等

| 常量   | 含义                         |
| ------ | ---------------------------- |
| in     | 打开文件, 准备读取           |
| out    | 打开文件, 准备写入           |
| ate    | 打开文件, 并移动到文件尾     |
| app    | 追加到文件尾                 |
| trunc  | 如果文件存在, 则清楚文件内容 |
| binary | 二进制文件                   |



#### 写文件

1. 创建一个ofstream对象来管理输出流, 假设对象名为`fcout`
2. 使用对象的`open()`方法将特定的文件关联为该流目标
3. 使用该对象来进行输出操作, 使用方法同`cout`对象一样

```c++
string s;
cin >> s;
ofstream fcout;
fcout.open("output.txt");
//ofstream fcout("output.txt", app);		//在创建对象时直接关联容器, 并选择文件模式为app
fcout << s << endl;
```

#### 读文件

1. 创建一个ifstream对象来管理输入流, 假设对象名为`fcin`
2. 使用对象的`open()`方法将特定文件关联为流源
3. 使用该对象来进行输入操作, 使用方法同`cin`对象一样

```c++
string s;
ifstream fcin;
fcin.open("input.txt");
fcin >> s;//fcin.getline(s, 10)或getline(fcin, s)
```

