# 开源软件发展<a name="1"></a>

>  **章节目录**
>
> + [开源协议](#1-1)
> + [开源软件的盈利模式](#1-2)
> + [开源软件的优势](#1-3)
> + [Linux系统的发展](#1-4)
> + [常见的Linux系统版本](#1-5)

## 开源协议<a name="1-1"></a>

从<u>GPL</u>到<u>MIT</u>的许可证协议越来越自由.

![](https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE.svg)

## 开源软件的盈利模式<a name="1-2"></a>

+ <u>多条产品线</u>

  如MySQL数据库便有个人版和企业版两种产品，个人版完全免费起到推广作用，企业版销售授权许可盈利。

+ <u>技术服务型</u>，

  JBoss应用服务器便是典型代表，软件可自由免费使用，通过技术文档、培训课程以及定制开发服务来盈利。

+ <u>软硬件结合</u>

  IBM公司在出售服务器时，一般会为用户捆绑销售AIX或Linux系统来确保硬件设施的盈利。

+ <u>技术出版物</u>

  O'Reilly即是一家开源公司，也是一家出版商，诸多优秀书籍便是由此产生。

+ <u>品牌和口碑</u>

## 开源软件的优势<a name="1-3"></a>

+ <u>低风险</u>

  使用闭源软件无疑在把命运交付给他人，一旦封闭的源代码没有人来维护，你将进退维谷，而相较于商业软件公司，开源社区则很少存在倒闭的问题。并且源代码一旦公布于世，任何人或组织都可以接替上任进行未来新的维护工作。

+ <u>高品质</u>

  相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的ug还没有等爆发就已经被修补。另外在灵感不断碰撞、代码不断迭代的交流氛围中，不会有程序员将”半成品”上传到开源社区中的。

+ <u>低成本</u>

  开源工作者大多都是在幕后默默且无偿地付出劳动成果，为美好的世界贡献一份力量，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力。

+ <u>更透明</u>

  没有哪个笨蛋会把木马或后门代码放到开源项目中的，这样无疑是把自己的罪行暴露在阳光之下，一眼就能被发现。

## Linux系统的发展<a name="1-4"></a>

1. Bell实验室, 通用电气公司, MIT决定联手打造一款操作系统<u>MULTICS</u>
2. MULTICS的开发并不顺利, 其中一位开发人员Ken Thompson使用汇编语言编写出一款新的系统内核<u>UNICS</u>
3. C语言之父Dennis M.Ritchie考虑到汇编语言的跨平台性很差, 因此使用C语言重新编写一遍UNICS系统, 即<u>UNIX系统</u>
4. 贝尔实验室的公司AT&T收回UNIX的版权, 逐步限制了UNIX系统源代码的自由传播
5. Richard Stallman发起<u>GNU源代码开放计划</u>并制定了<u>GPL许可证</u>, 在和社区成员的共同履历下编写出了一款能够运行C语言代码的编译器<u>gcc(GNU C Compiler)</u>
6. 荷兰教授仿照UNIX系统编写出一款<u>Minix操作系统</u>, 用于课堂教学
7. Linus Torvalds使用bash解释器和gcc编译器编写了一个全新的<u>系统内核Linux</u>
8. 红帽公司创始人Bob Young在Linux系统内核的基础之上, 集成了众多常用源代码和程序软件, 发布RedHat操作系统并开始出售技术服务, 推动了Linux系统的普及.
9. IBM和Intel为首的多家IT巨头开始大力推动开源软件的发展. 红帽公司也成为了世界上第一家年收入10亿美元的开源公司.

## 常见的Linux系统版本<a name="1-5"></a>

+ <u>红帽企业版系统(RHEL, RedHatEntrepriseLinux)</u>

  极强的稳定性

+ <u>CentOS(Community Enterprise Operation System)</u>

  免费, 将RHEL中的付费功能去掉之后的版本

+ <u>Fedora</u>

  桌面版本系统, 类似于Windows10, 是<u>RHEL系统的试验田</u>, 一些新功能新特性会放到该系统中进行测试, 技术成熟之后才移植到RHEL系统中

+ <u>Debian</u>

  非红帽公司出品, 使用`apt`作为包管理工具

+ <u>Ubuntu</u>

  桌面版本系统, 基于Debian系统, 修改衍生而来

+ <u>Kali Linux</u>

  一般是被黑客或安全人员使用, 能够对网站进行渗透测试, 即“<u>攻击网站</u>”

# 动手部署一台Linux操作系统

> **章节目录**
>
> + [安装并配置VM虚拟机](#2-1)
> + [安装Linux系统](#2-2)
> + [Linux系统中安装软件](#2-3)
> + [系统初始化进程](#2-4)
> + [重置root用户密码](#2-5)

## 安装并配置VM虚拟机<a name="2-1"></a>

<u>三种模式</u>

+ 桥接模式

  虚拟机可以通过物理主机的网卡访问外部网络, 占用物理IP地址, 主机数过多时可能存在IP冲突

+ NAT模式

  VM虚拟机中的网络服务相当于路由器的作用, 虚拟机可以访问外网, 对应的网卡为VMnet8

+ 仅主机模式

  不能访问外网, 对应的网卡为VMnet1

## 安装Linux系统<a name="2-2"></a>

安装RHEL8或CentOS8系统时，物理电脑的CPU需要支持虚拟化技术(Virtualization Technology), 简称VT。

VT技术是一种能够让单台计算机分割出多个独立资源区，并让每个资源区按照需要模拟出系统的一项技术，其本质就是通过中间层实现计算机资源的管理和再分配，让系统资源的利用率最大化。

VT虚拟化大多数情况下时默认开启的, 万一没有开启, 则在开机时进入到BIOS面板中进行开启.

## Linux系统中安装软件<a name="2-3"></a>

在RPM（红帽软件包管理器）公布之前，要想在Linux系统中安装软件只能采取编译源码包的方式，所以早期安装软件是一件非常困难、耗费耐心的事情，而且大多数的服务程序仅仅提供自身的源代码，还需要运维人员编译代码后自行解决软件之间的依赖关系。因此要安装好一个服务程序，运维人员不仅需要具备丰富的知识、高超的技能，还要有良好的耐心，这其中的艰辛我们会在本书第20章节为读者们实战演练一遍。

总而言之，早期Linux系统在安装、升级、卸载服务程序时还要考虑到其他程序、库的依赖关系，所以在进行校验、安装、卸载、查
询、升级等管理软件操作时难度都非常大，RPM机制则正是为了解决这些问题而设计的。

通过RPM安装的服务程序会像Windows系统中的控制面板那样，建立统一的数据库，详细记录软件信息并能够自动分析依赖关系。

# Linux系统中必须掌握的常用命令

在输入命令之前就已经存在的那部分内容, 例如`[root@hadoop100 ~]# `称为<u>终端提示符</u>. 

终端提示符用于提示一些基本信息, `#`结尾代表管理员身份, `?`结尾代表普通用户身份.

## 帮助文档`man`的使用

<center>man命令中常用按键及其作用</center>

| 按键              | 功能                                 |
| ----------------- | ------------------------------------ |
| `空格键/Pagedown` | 向下翻页                             |
| `Pageup`          | 向上翻页                             |
| `home`            | 跳转首页                             |
| `end`             | 跳转尾页                             |
| `/`               | 从上到下搜索某个关键字, 例如`/linux` |
| `?`               | 从下到上搜索某个关键字, 例如`?linux` |
| `n`               | 搭配搜索功能使用, 定位到下一个关键字 |
| `N`               | 搭配搜索功能使用, 定位到上一个关键字 |
| `q`               | 退出                                 |

## `echo`命令

| 命令     | 介绍                                                         |
| -------- | ------------------------------------------------------------ |
| 作用     | `echo`命令用于<u>在终端设备上输出字符串或变量提取后的值</u>  |
| 语法格式 | `echo <字符串>`或者`echo <$变量名>`<br />`$`表示取变量的实际值 |

```bash
[root@hadoop100 ~]# echo $SHELL
/bin/bash
[root@hadoop100 ~]# echo SHELL
SHELL
```

## `date`命令

