# 开源软件发展<a name="1"></a>

>  **章节目录**
>
> + [开源协议](#1-1)
> + [开源软件的盈利模式](#1-2)
> + [开源软件的优势](#1-3)
> + [Linux系统的发展](#1-4)
> + [常见的Linux系统版本](#1-5)

## 开源协议<a name="1-1"></a>

从<u>GPL</u>到<u>MIT</u>的许可证协议越来越自由.

![](https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE.svg)

## 开源软件的盈利模式<a name="1-2"></a>

+ <u>多条产品线</u>

  如MySQL数据库便有个人版和企业版两种产品，个人版完全免费起到推广作用，企业版销售授权许可盈利。

+ <u>技术服务型</u>，

  JBoss应用服务器便是典型代表，软件可自由免费使用，通过技术文档、培训课程以及定制开发服务来盈利。

+ <u>软硬件结合</u>

  IBM公司在出售服务器时，一般会为用户捆绑销售AIX或Linux系统来确保硬件设施的盈利。

+ <u>技术出版物</u>

  O'Reilly即是一家开源公司，也是一家出版商，诸多优秀书籍便是由此产生。

+ <u>品牌和口碑</u>

## 开源软件的优势<a name="1-3"></a>

+ <u>低风险</u>

  使用闭源软件无疑在把命运交付给他人，一旦封闭的源代码没有人来维护，你将进退维谷，而相较于商业软件公司，开源社区则很少存在倒闭的问题。并且源代码一旦公布于世，任何人或组织都可以接替上任进行未来新的维护工作。

+ <u>高品质</u>

  相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的ug还没有等爆发就已经被修补。另外在灵感不断碰撞、代码不断迭代的交流氛围中，不会有程序员将”半成品”上传到开源社区中的。

+ <u>低成本</u>

  开源工作者大多都是在幕后默默且无偿地付出劳动成果，为美好的世界贡献一份力量，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力。

+ <u>更透明</u>

  没有哪个笨蛋会把木马或后门代码放到开源项目中的，这样无疑是把自己的罪行暴露在阳光之下，一眼就能被发现。

## Linux系统的发展<a name="1-4"></a>

1. Bell实验室, 通用电气公司, MIT决定联手打造一款操作系统<u>MULTICS</u>
2. MULTICS的开发并不顺利, 其中一位开发人员Ken Thompson使用汇编语言编写出一款新的系统内核<u>UNICS</u>
3. C语言之父Dennis M.Ritchie考虑到汇编语言的跨平台性很差, 因此使用C语言重新编写一遍UNICS系统, 即<u>UNIX系统</u>
4. 贝尔实验室的公司AT&T收回UNIX的版权, 逐步限制了UNIX系统源代码的自由传播
5. Richard Stallman发起<u>GNU源代码开放计划</u>并制定了<u>GPL许可证</u>, 在和社区成员的共同履历下编写出了一款能够运行C语言代码的编译器<u>gcc(GNU C Compiler)</u>
6. 荷兰教授仿照UNIX系统编写出一款<u>Minix操作系统</u>, 用于课堂教学
7. Linus Torvalds使用bash解释器和gcc编译器编写了一个全新的<u>系统内核Linux</u>
8. 红帽公司创始人Bob Young在Linux系统内核的基础之上, 集成了众多常用源代码和程序软件, 发布RedHat操作系统并开始出售技术服务, 推动了Linux系统的普及.
9. IBM和Intel为首的多家IT巨头开始大力推动开源软件的发展. 红帽公司也成为了世界上第一家年收入10亿美元的开源公司.

## 常见的Linux系统版本<a name="1-5"></a>

+ <u>红帽企业版系统(RHEL, RedHatEntrepriseLinux)</u>

  极强的稳定性

+ <u>CentOS(Community Enterprise Operation System)</u>

  免费, 将RHEL中的付费功能去掉之后的版本

+ <u>Fedora</u>

  桌面版本系统, 类似于Windows10, 是<u>RHEL系统的试验田</u>, 一些新功能新特性会放到该系统中进行测试, 技术成熟之后才移植到RHEL系统中

+ <u>Debian</u>

  非红帽公司出品, 使用`apt`作为包管理工具

+ <u>Ubuntu</u>

  桌面版本系统, 基于Debian系统, 修改衍生而来

+ <u>Kali Linux</u>

  一般是被黑客或安全人员使用, 能够对网站进行渗透测试, 即“<u>攻击网站</u>”

# 动手部署一台Linux操作系统

> **章节目录**
>
> + [安装并配置VM虚拟机](#2-1)
> + [安装Linux系统](#2-2)
> + [Linux系统中安装软件](#2-3)
> + [系统初始化进程](#2-4)
> + [重置root用户密码](#2-5)

## 安装并配置VM虚拟机<a name="2-1"></a>

<u>三种模式</u>

+ 桥接模式

  虚拟机可以通过物理主机的网卡访问外部网络, 占用物理IP地址, 主机数过多时可能存在IP冲突

+ NAT模式

  VM虚拟机中的网络服务相当于路由器的作用, 虚拟机可以访问外网, 对应的网卡为VMnet8

+ 仅主机模式

  不能访问外网, 对应的网卡为VMnet1

## 安装Linux系统<a name="2-2"></a>

安装RHEL8或CentOS8系统时，物理电脑的CPU需要支持虚拟化技术(Virtualization Technology), 简称VT。

VT技术是一种能够让单台计算机分割出多个独立资源区，并让每个资源区按照需要模拟出系统的一项技术，其本质就是通过中间层实现计算机资源的管理和再分配，让系统资源的利用率最大化。

VT虚拟化大多数情况下时默认开启的, 万一没有开启, 则在开机时进入到BIOS面板中进行开启.

## Linux系统中安装软件<a name="2-3"></a>

在RPM（红帽软件包管理器）公布之前，要想在Linux系统中安装软件只能采取编译源码包的方式，所以早期安装软件是一件非常困难、耗费耐心的事情，而且大多数的服务程序仅仅提供自身的源代码，还需要运维人员编译代码后自行解决软件之间的依赖关系。因此要安装好一个服务程序，运维人员不仅需要具备丰富的知识、高超的技能，还要有良好的耐心，这其中的艰辛我们会在本书第20章节为读者们实战演练一遍。

总而言之，早期Linux系统在安装、升级、卸载服务程序时还要考虑到其他程序、库的依赖关系，所以在进行校验、安装、卸载、查
询、升级等管理软件操作时难度都非常大，RPM机制则正是为了解决这些问题而设计的。

通过RPM安装的服务程序会像Windows系统中的控制面板那样，建立统一的数据库，详细记录软件信息并能够自动分析依赖关系。



# Linux系统中必须掌握的常用命令

在输入命令之前就已经存在的那部分内容, 例如`[root@hadoop100 ~]# `称为<u>终端提示符</u>. 

终端提示符用于提示一些基本信息, `#`结尾代表管理员身份, `?`结尾代表普通用户身份.

## 帮助文档`man`的使用

<center>man命令中常用按键及其作用</center>

| 按键              | 功能                                 |
| ----------------- | ------------------------------------ |
| `空格键/Pagedown` | 向下翻页                             |
| `Pageup`          | 向上翻页                             |
| `home`            | 跳转首页                             |
| `end`             | 跳转尾页                             |
| `/`               | 从上到下搜索某个关键字, 例如`/linux` |
| `?`               | 从下到上搜索某个关键字, 例如`?linux` |
| `n`               | 搭配搜索功能使用, 定位到下一个关键字 |
| `N`               | 搭配搜索功能使用, 定位到上一个关键字 |
| `q`               | 退出                                 |

## `echo`命令

| 命令     | 介绍                                                         |
| -------- | ------------------------------------------------------------ |
| 作用     | `echo`命令用于<u>在终端设备上输出字符串或变量提取后的值</u>  |
| 语法格式 | `echo <字符串>`或者`echo <$变量名>`<br />`$`表示取变量的实际值 |

```bash
[root@hadoop100 ~]# echo $SHELL
/bin/bash
[root@hadoop100 ~]# echo SHELL
SHELL
```

## `date`命令

# 管道符, 重定向与环境变量

> + [输入输出重定向](#4-1)
> + [管道命令符](#4-2)
> + [命令行的通配符](#4-3)
> + [常用的转义字符](#4-4)
> + [重要的环境变量](#4-5)

## 输入输出重定向<a name="4-1"></a>

<u>输入重定向</u>是指从指定文件中读取输入数据, 而<u>输出重定向</u>是指把原本要输出到屏幕的数据信息写入到指定文件中.

输出重定向的使用频率更高, 又将其分为<u>标准输出重定向</u>和<u>错误输出重定向</u>两种不同的技术, 以及<u>清空写入</u>和<u>追加写入</u>两种模式.

三种输入输出重定向技术:

+ 标准输入重定向(STDIN, 文件描述符为0): 默认从键盘输入, 也可以从其他文件或命令中输入

+ 标准输出重定向(STDOUT, 文件描述符为1): 默认输出到屏幕

+ 错误输出重定向(STDERR, 文件描述符为2): 默认输出到屏幕

文件描述符中的1可以省略不写, 但是文件描述符中的2必须要写, 例如下表所示.

<center>重定向技术中用到的符号</center>

| 符号   | 作用                                               |
| ------ | -------------------------------------------------- |
| `<`    | 将文件作为命令的标准输入                           |
| `<<`   | 指定标准输入中的结束符                             |
| `>`    | 将标准输出重定向到一个文件中, 清空文件中原有数据   |
| `2>`   | 将错误输出重定向到一个文件中, 清空文件中原有数据   |
| `>>`   | 将标准输出重定向到一个文件中, 追加数据             |
| `2>>`  | 将错误输出重定向到一个文件中, 追加数据             |
| `&>> ` | 将标准输出和错误输出共同写入到一个文件中, 追加数据 |

## 管道命令符<a name="4-2"></a>

==管道命令符`|`的作用是: 将前一个命令的标准输出作为后一个命令的标准输入==

修改root用户命令: `echo "password" | passwd --stdin root`

```bash
[root@hadoop100 ~]# echo "xiong" | passwd --stdin xiong
Changing password for user xiong.
passwd: all authentication tokens updated successfully.
```

如果要将管道命令符处理后的结果==既输出到屏幕上, 又添加到文件中==, 可以搭配`tee`命令使用.

```bash
[root@hadoop100 ~]# ps aux | grep bash
root       1502  0.0  0.0 115540  1976 tty1     Ss+  15:44   0:00 -bash
root       1524  0.0  0.0 115544  2052 pts/0    Ss   15:44   0:00 -bash
root       1553  0.0  0.0 112808   964 pts/0    R+   15:48   0:00 grep --color=auto bash
[root@hadoop100 ~]# ps aux | grep bash | tee psAux_grepBash
# 创建了psAux_grepBash文件用来保存输出结果
root       1502  0.0  0.0 115540  1976 tty1     Ss+  15:44   0:00 -bash
root       1524  0.0  0.0 115544  2052 pts/0    Ss   15:44   0:00 -bash
root       1556  0.0  0.0 112808   960 pts/0    S+   15:49   0:00 grep --color=auto bash
[root@hadoop100 ~]# ls
anaconda-ks.cfg  hardLink  installed_software  LinuxProbe.pdf  original-ks.cfg  psAux_grepBash  test
[root@hadoop100 ~]# cat psAux_grepBash 
root       1502  0.0  0.0 115540  1976 tty1     Ss+  15:44   0:00 -bash
root       1524  0.0  0.0 115544  2052 pts/0    Ss   15:44   0:00 -bash
root       1556  0.0  0.0 112808   960 pts/0    S+   15:49   0:00 grep --color=auto bash
```

## 命令行中的通配符<a name="4-3"></a>

<center>Linux系统中的通配符</center>

| 通配符      | 含义           |
| ----------- | -------------- |
| `*`         | 任意字符       |
| `?`         | 单个任意字符   |
| `[a-z]`     | 单个小写字母   |
| `[A-Z]`     | 单个大写字母   |
| `[0-9]`     | 单个数字       |
| `[:alpha:]` | 任意字母       |
| `[:upper:]` | 任意大写字母   |
| `[:lower:]` | 任意小写字母   |
| `[:digit:]` | 所有数字       |
| `[:alnum:]` | 任意字母加数字 |
| `[:punct:]` | 标点符号       |

## 转义字符<a name="4-4"></a>

+ 反斜杠`\`: 使其后面的一个字符变为纯文本字符
+ 单引号`‘’`: 将单引号中的所有内容作为纯文本
+ 双引号`“”`: 保留其中的变量
+ 反引号: 将其中的内容作为命令进行执行, 并返回执行结果

```bash
[root@hadoop100 ~]# price=5
[root@hadoop100 ~]# echo 'price is $price'
price is $price
[root@hadoop100 ~]# echo "price is $$price"
price is 1524price
[root@hadoop100 ~]# echo "price is $price"
price is 5
[root@hadoop100 ~]# echo "price is \$$price"
price is $5
[root@hadoop100 ~]# echo `echo $price`
5
```

## 环境变量<a name="4-5"></a>

在Linux系统中, 一般用大写字母表示变量名, 用小写字母表示命令(命名规范).

<u>命令执行流程</u>:

1. 通过==绝对路径或相对路径==的方式来尝试执行该命令
2. ==检查==输入的命令是否是自定义的==别名==
3. 判断用户输入的是Bash Shell的内部命令还是外部命令(内外部命令是针对Bash程序而言的)
4. 在系统定义的PATH变量的文件夹下查找命令

<u>环境变量本质就是在命令行中定义变量</u>, 和上面的`price=5`没有差别. 有两点不同的是:

+ `price`变量不能被其他用户所使用, 因此需要使用`export`关键字来将其提升为==全局变量==
+ `price`变量在服务器重启后就会消失掉, 因此需要将其写入到`.bashrc`或`.bash_profile`配置文件中

# Vim编辑器

vi编辑器是Unix系统最初始的编辑器, 在GNU项目将vi编辑器一直到开源世界后, 将其进行一些改进, 并重命名为vim(vi improved)

## vim安装

在Centos7系统中, 使用`yum install -y vim`进行安装

在Ubuntu系统中, 使用`sudo apt-get install vim`进行安装

## vim基础

vim在内存缓冲区中处理数据

+ 未指定文件名或文件不存在, 则开辟一段新的缓冲区域来编辑
+ 指定文件存在, 则将文件的整个内容读入到缓冲区中

vim编辑器有两种操作模式: <u>普通模式和插入模式</u>. 在普通模式下, 输入的按键将会被解释为命令(<u>区分大小写</u>); 在插入模式下则输入文本内容.

<center>vim操作模式的相互转换</center> 

<img src="https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%A8%A1%E5%BC%8F.svg" style="zoom:25%;" />

### 普通模式

+ `方向键`: 上下左右
+ `<PageDown>/<PageUp>`: 向下/上翻页
+ `G`: 移到文本的最后一行
+ `gg`: 移动到文本的第一行
+ `<num> G`: 移动到文本的第`num`行
+ `:`: <u>命令行模式</u>
  + `q`: 如果未修改缓冲区数据, 则可以退出
  + `q!`: 取消对数据的修改并退出, 强制退出
  + `w <filename>`: 将数据保存到一个名为`filename`的文件中
  + `wq`: 保存数据修改并退出

#### 编辑命令

<center>vim编辑命令</center>

| 命令         | 描述                                                         | 拓展使用 |
| ------------ | ------------------------------------------------------------ | -------- |
| `x/<Delete>` | <u>删除</u>当前光标所在位置的字符                            | `2x`     |
| `dd`         | <u>删除</u>当前光标所在<u>行</u>的字符串                     | `5dd`    |
| `dw`         | <u>删除</u>当前光标所在位置的<u>单词</u>                     |          |
| `d$`         | <u>删除</u>当前光标至<u>行尾(`$`)</u>的内容                  |          |
| `J`          | <u>删除</u>当前光标所在行行尾的<u>换行符(即拼接行)</u>       |          |
| `u`          | <u>撤销</u>                                                  |          |
| `a`          | 在当前光标位置后<u>追加数据</u>                              |          |
| `A`          | 在当前光标所在行<u>行尾追加数据</u>                          |          |
| `r <char>`   | 用`<char>`字符替换当前光标所在位置的<u>单个字符</u>          |          |
| `R <text>`   | 用`<text>`覆盖当前光标所在位置的数据, 直到按下esc键(<u>进入到REPLACE模式</u>) |          |

<u>删除命令</u>会将删除数据存放到寄存器中, 使用`p`命令可以取回数据, 搭配使用相当于`剪切 + 粘贴`

#### 复制和粘贴

复制命令和删除命令相类似, 只需要将`d`改为`y`即可. 由于复制不会影响到复制的文本, 因此只有当使用`p`命令进行粘贴之后才能清楚实际复制了什么内容. 当然, 这个问题可以通过<u>可视模式</u>进行解决, 按下`v`键会高亮文本, <u>高亮的内容即为选中的文本</u>

#### 查找和替换

1. 输入`/`, 再输入需要查找的内容(<u>区分大小写</u>), 按下回车键即可查找
2. 找到内容后, 使用`n`可以查看下一个
3. 在<u>命令行模式</u>下才可以使用替换功能, 格式为`:s /<old>/<new>`

<center>替换功能格式</center>

| 格式                   | 功能                                                   |
| ---------------------- | ------------------------------------------------------ |
| `:s /<old>/<new>`      | 从当前光标到文件末尾查找`<old>`并将第一个替换为`<new>` |
| `:s /<old>/<new>/g`    | 将当前光标所在行的`<old>`替换为`<new>`                 |
| `:n,ms /<old>/<new>/g` | 替换从行号`n`到行号`m`之间所有的`<old>`                |
| `:%s /<old>/<new>/g`   | 替换整个文件中所有的`<old>`                            |
| `:%s /<old>/<new>/gc`  | 替换整个文件中所有的`<old>`且每次进行提示确认          |

## Vim其它设置

通过`vim ~/.vimrc`命令创建(或打开)`.vimrc`文件, 具体配置信息如下

<center>.vimrc文件配置及其含义</center>

| 文件配置        | 含义                 |
| --------------- | -------------------- |
| set hlsearch    | 高亮度反白           |
| set backspace=2 | 可随时用退格键删除   |
| set autoindent  | 自动缩进             |
| set ruler       | 可显示最后一行的状态 |
| set showmode    | 左下角那一行的状态   |
| set nu          | 显示行号             |
| set bg=dark     | 显示不同的底色       |
| syntax on       | 语法高亮             |

# Shell脚本

## 接收参数

Shell脚本内设置了一些用于接收参数的变量, 变量和变量之间用空格隔开.

<center>Shell脚本中的参数</center>

| 变量              | 含义                     |
| ----------------- | ------------------------ |
| `$0`              | 当前Shell脚本程序的名称  |
| `$#`              | 参数的个数               |
| `$1, $2, ..., $N` | 第1, 2, …, N个位置的参数 |
| `$*`              | 所有位置的参数值         |
| `$?`              | 上一次命令的执行返回值   |

编写`example.sh`脚本, 内容如下. 其中第一行表示告诉系统使用bash这种Shell解释器来执行脚本文件.

```bash
#! /bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数, 分别是$*"
echo "第一个参数是$1, 第二个参数是$2"
```

可以使用`bash example.sh`来执行脚本文件, 也可以使用`./example.sh`来执行, 但是默认情况下该文件被当作普通文件, 没有执行权限, 通过`chmod u+x example.sh`来为文件添加执行权限之后才可以使用`./example.sh`来执行文件. ==(此时example.sh文件有颜色渲染)==

```shell
[root@hadoop100 ~]# ./example.sh hello world
当前脚本名称为./example.sh
总共有2个参数, 分别是hello world
第一个参数是hello, 第二个参数是world
```



## 逻辑表达式

系统在执行`mkdir`命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。

Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回非零值。

格式: `[ <expression> ]`, <u>括号和表达式之间需要用空格隔开</u>

### 文件测试语句

<center>文件测试参数表</center>

| 选项 | 作用                       |
| ---- | -------------------------- |
| `-d` | 测试文件是否为目录类型     |
| `-e` | 测试文件是否存在           |
| `-f` | 判断是否为一般文件         |
| `-r` | 测试当前用户是否有权限读取 |
| `-w` | 测试当前用户是否有权限写入 |
| `-x` | 测试当前用户是否有权限执行 |

> 测试`example.sh`文件是否属于目录类型

```shell
[root@hadoop100 ~]# [ -d example.sh ]
[root@hadoop100 ~]# echo $?
1
```

### 逻辑运算符

#### `&&`与操作

与其它高级编程语言不同, `&&`表示==当前面的命令执行成功时, 才执行后面的操作==.

#### `||`或操作

`||`表示==当前面的命令执行失败时, 才执行后面的操作==

> 测试`example.sh`文件是否存在, <u>使用逻辑运算符&&</u>

```bash
[root@hadoop100 ~]# [ -e example.sh ] && echo $?
0
```

> 测试当前用户是否为root用户, <u>使用逻辑运算符||</u>

```bash
[root@hadoop100 ~]# [ $USER != root ] || echo "root"
root
```

> <u>三目运算符的使用</u>: 若当前用户为root, 则输出“root”, 否则输出“user”

```bash
[root@hadoop100 ~]# [ $USER = root ] && echo "root" || echo "user"
root
```

### 数值比较语句

因为`>, <, =`等符号分别用来表示输出重定向, 输入重定向, 赋值等操作, 因此需要使用字母符号

<center>整数比较运算符</center>

| 比较运算符 | 作用 |
| ---------- | ---- |
| `-eq`      | ==   |
| `-ne`      | !=   |
| `-gt`      | >    |
| `-lt`      | <    |
| `-le`      | <=   |
| `ge`       | >=   |

```bash
[root@hadoop100 ~]# [ 10 -ge 10 ] && echo "yes"
yes
```

### 字符串比较语句

<center>字符串比较运算符</center>

| 比较操作符 | 作用                   |
| ---------- | ---------------------- |
| `=`        | 比较字符串内容是否相同 |
| `!=`       | 比较字符串内容是否不同 |
| `-z`       | 判断字符串内容是否为空 |

```bash
[root@hadoop100 ~]# [ -z $string ] && echo "string is null"
string is null
```

## 流程控制语句

### if语句

<u>单分支结构</u>由`if, then, fi`关键词组成

```bash
DIR="/media/cdrom"
if [ ! -e $DIR ] #如果DIR不是一个目录类型
then 
	mkdir -p $DIR
fi
```

<u>双分支结构</u>由`if, then, else, fi`关键字组成

```bash
#! /bin/bash
# /dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据(类似于没有回收功能的垃圾箱)
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null

if [ $? -eq 0 ]
then
	echo "Host $1 is Online"
else
	echo "Host $1 is Offline"
fi
```

```bash
[root@hadoop100 ~]# bash pingtest.sh hadoop100
Host hadoop100 is Online
```

<u>多分支结构</u>由`if, then, else, elif, fi`关键词组成

```bash
#!/bin/bash
read -p "Enter your score (0-100):" GRADE #获取输入, 赋值给变量GRADE, 相当于input
if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ] ; then
        echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] && [ $GRADE -le 84 ] ; then
        echo "$GRADE is Pass"
else
        echo "$GRADE is Fail" 
fi
```

### for语句

```bash
for 变量名 in 取值列表
do
	执行流程
done
```

### while语句

可以使用`exit`关键字来强行退出循环, 类似`break`的功能

```bash
while 逻辑表达式
do
	执行流程
done
```

### case语句

```bash
case 变量值 in
模式1)
	流程1
	;;
模式2)
	流程2
	;;
*)
	流程3
esac
```

## 计划任务服务程序

在指定的时间段自动启用或停止某些服务或命令.

计划任务分为<u>一次性计划任务</u>和<u>长期性计划任务</u>.

<center>at命令参数表</center>

| 参数 | 作用                   |
| ---- | ---------------------- |
| `-f` | 指定包含命令的任务文件 |
| `-q` | 指定新任务名称         |
| `-l` | 显示待执行任务的列表   |
| `-d` | 删除指定待执行任务     |
| `-m` | 任务执行后给用户发邮件 |

`at`命令默认情况下使用交互式方式, 在输入`at <time>`之后, 会让用户输入待执行的任务

```bash
[root@hadoop100 ~]# at 23:00
at> poweroff
at> <EOT>
job 1 at Mon Jun 13 23:00:00 2022
Can't open /var/run/atd.pid to signal atd. No atd running? #似乎对正确执行脚本没有影响
```

通过管道符来实现非交互式方式的脚本方式

```bash
[root@hadoop100 ~]# echo "poweroff" | at 23:00
```

# 用户身份与文件权限

> + 用户身份与能力
> + 文件权限与归属
> + 文件的特殊权限
> + 文件的隐藏属性
> + 文件访问控制列表
> + su命令与sudo服务

Linux时一个多用户, 多任务的操作系统. 本章介绍如何添加, 删除, 修改用户账户信息. 

<u>文件访问控制列表(Access Control List, ACL)</u>可以进一步让单一用户或用户组对文件或目录进行权限设置, <u>使得文件具有满足工作需求的最小权限.</u>

## 用户身份与能力

Linux系统的设计初衷之一是为了满足多个用户同时工作的需求, 因此必须具备很好的安全性, 尤其是不能因为一两个服务出错而影响到整台服务器.

root管理员就是存在于所有类UNIX系统中的超级用户, 它拥有最高的系统所有权，能够管理系统的各项功能，如添<u>加/删除用户、启动/关闭服务进程、开启/禁用硬件设备</u>等. root管理员工作时不会受到系统的限制, 但如果root管理员执行了错误的[Linux命令](https://www.linuxcool.com/), 可能会直接毁掉整个系统.

### UID

+ uid=0: root用户
+ uid$\in$[1,999]: 系统用户, 执行系统服务进程
+ uid$\in$[1000, $+\infty$): root用户创建的普通用户

### GID

在Linux系统中创建每个用户时，将自动创建一个与其同名的<u>基本用户组</u>，而且这个基本用户组只有该用户一个人。如果该用户以后被归纳到其他用户组，则这个其他用户组称之为<u>扩展用户组</u>。一个用户只有一个基本用户组，但是可以有多个扩展用户组

基本用户组相当于==“我”==这个组, 有且只有一个成员. 而<u>扩展用户组则相当于用户的身份</u>, 用户可以有不同的身份, 例如既可以是男性, 也可以是学生, 还可以是志愿者. 

如果扩展组被删除, 则该组中用户的扩展组会重新变为其基本用户组.

## 命令

### id命令

用于显示用户的详细信息, 分别是uid(用户id), gid(基本用户组id), groups(扩展组id)

```bash
[root@hadoop100 ~]# id root
uid=0(root) gid=0(root) groups=0(root)
[root@hadoop100 ~]# id xiong
uid=1000(xiong) gid=1000(xiong) groups=1000(xiong)
```

### useradd命令

用于创建普通用户

```bash
[root@hadoop100 ~]# useradd tom
[root@hadoop100 ~]# id tom
uid=1001(tom) gid=1001(tom) groups=1001(tom)
```

### userdel命令

用于删除用户, 虽然用户已经被删除, 但是其目录数据仍然存放在其家目录中, 需要手动进行删除.

```bash
[root@hadoop100 ~]# userdel tom
[root@hadoop100 ~]# useradd tom
useradd: warning: the home directory already exists.
Not copying any file from skel directory into it.
Creating mailbox file: File exists
```

### groupadd命令

用于创建扩展组

```bash
[root@hadoop100 ~]# groupadd people
```



### usermod命令

用于修改用户的属性. 在Linux系统中一切都是文件, 因此可以使用`usermod`命令来修改用户信息.

<center>usermod命令选项参数表</center>

| 选项  | 作用                                     |
| ----- | ---------------------------------------- |
| `-c`  | 填写用户账户的备注信息                   |
| `-dm` | 重新指定用户的家目录, 并将旧数据迁移过去 |
| `-e`  | 账户的到期时间, 格式为YYYY-mm-DD         |
| `-g`  | 变更所属的用户组                         |
| `-G`  | 变更所属的扩展组                         |
| `-L`  | 将用户加入黑名单, 禁止其登录系统         |
| `-U`  | 解除黑名单限制                           |
| `-s`  | 变更默认终端                             |
| `-u`  | 修改用户的UID                            |

```bash
# 将用户tom添加到扩展组people中
[root@hadoop100 ~]# usermod -G people tom
[root@hadoop100 ~]# id tom
uid=1001(tom) gid=1001(tom) groups=1001(tom),1002(people)
```

### passwd命令

用于修改用户密码

```bash
[root@hadoop100 ~]# passwd --stdin xiong
Changing password for user xiong.
xiong
passwd: all authentication tokens updated successfully.
```

<center>passwd命令选项参数表</center>

| 选项      | 作用                                             |
| --------- | ------------------------------------------------ |
| `-l`      | 加黑名单                                         |
| `-u`      | 解除黑名单                                       |
| `--stdin` | 允许通过标准输入来修改用户密码                   |
| `-d`      | 删除用户密码, 之后可以不使用密码进行登录         |
| `-e`      | 强制用户在下次登录时修改密码                     |
| `-S`      | 显示用户密码是否被锁定, 以及密码所采用的加密算法 |

## 文件权限与归属

### 文件权限

在Linux系统中，每个文件都有归属的所有者和所属组，并且规定了文件的所有者、所属组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限.

<center>文件和目录的权限</center>

| 权限      | 文件           | 目录       |
| --------- | -------------- | ---------- |
| 读取(r=4) | `cat`          | `ls`       |
| 写入(w=2) | `vim`          | `touch/mv` |
| 执行(x=1) | `./<filename>` | `cd`       |

<u>对文件</u>

+ ==可读==: 能够读取文件的实际内容
+ ==可写==: 能够编辑, 新增, 修改, 删除文件的实际内容
+ ==可执行==: 能够运行一个脚本程序

<u>对目录</u>

+ ==可读==: 能够读取目录中的文件列表
+ ==可写==: 能够在目录内增加, 删除, 重命名文件
+ ==可执行==: 能够进入到该目录中

### 文件类型

在下面列出的文件信息中, 依次分别是==文件类型, ugo的文件权限, 硬链接数量, 属主, 属组, 占用大小, 修改时间, 文件名==. 

<u>第一位字符表示文件类型</u>, 常见的文件类型见[表7-4](#table7-4)

```bash
[root@hadoop100 ~]# ls -l
total 17556
-rw-------. 1 root root     2610 Jun  5 14:14 anaconda-ks.cfg
-rwxr--r--. 1 root root      136 Jun 13 19:50 example.sh
-rw-r--r--. 1 root root      581 Jun  9 14:32 hardLink
-rw-r--r--. 1 root root    34960 Jun  8 19:35 installed_software
-rw-r--r--. 1 root root 17676281 Sep 22  2020 LinuxProbe.pdf
-rwxr--r--. 1 root root       66 Jun 13 21:26 mkdir.sh
-rw-------. 1 root root     2045 Jun  8 18:06 original-ks.cfg
-rw-r--r--. 1 root root      134 Jun 13 21:30 pingtest.sh
-rw-r--r--. 1 root root      233 Jun 13 15:49 psAux_grepBash
-rw-r--r--. 1 root root   233354 Jun 10 18:57 test
```

普通文件的范围最广泛, 例如纯文本信息, 配置文件, 日志文件, shell脚本等.

目录文件的范围也比较广泛.

块设备文件和字符设备文件一般是指硬件设备, 比如鼠标, 键盘, 光驱, 硬盘等.

<center><a name="table7-4"></a>文件类型参数表</center>

| 符号 | 文件类型   |
| ---- | ---------- |
| `-`  | 普通文件   |
| `d`  | 目录文件   |
| `l`  | 链接文件   |
| `p`  | 管道文件   |
| `b`  | 块设备文件 |
| `c`  | 字符文件   |

## 文件的特殊权限

特殊权限是用来弥补一般权限不能实现的功能, 是对一般权限的一种补充, 通常和一般的文件权限rwx搭配使用.

### SUID权限

SUID权限是一种对二进制程序设置的特殊权限, 能够==让二进制程序的执行者临时拥有所有者的权限==. <u>SUID权限仅仅对拥有执行权限的二进制程序有效.</u>

对一个应用程序, 在Linux系统中实际上就是一个命令, 例如`passwd`命令, 通过`ls -l /bin/passwd`查看其信息

```bash
[root@hadoop100 /]# ls -l /bin/passwd
-rwsr-xr-x. 1 root root 27856 Apr  1  2020 /bin/passwd
```

可以看到拥有者的文件权限为`rws`, 其中的`s`即表示该程序具有SUID权限. 
