# 绪论<a name="sec1"></a>

Linux是一个真正的Unix内核, 但它不是一个完全的Unix操作系统, 这是因为它不包含全部的Uix应用程序, 诸如文件系统实用程序、窗口系统及图形化桌面、系统管理员命令, 文本编辑程序、编译程序等等. 不过, 因为以上大部分应用程序都可在GNU许可证下免费获得, 因此, 可以把它们安装在任何一个基于Liux内核的系统中. 

因为Liux内核需要大量运行其他软件才能为用户提供一个有用的环境, 因此很多Linux用户更喜欢依赖从CD-ROM获得的商业发布版, 以得到包含在标准Unix系统中的应用层代码. 另外, 这些支持应用的源代码也可以从几个不同的网站获得, 例如https://www.kernel.org. 一些发布版将Linux源代码安装在`/usr/src/linux`目录下. 在本书的其余部分, 所有文件的目录都暗指这一目录. 

## Linux与其它Unix Like内核的比较

市场上各种类Unix系统在很多重要的方面有所不同, 其中有些系统已经有很长的历史, 并且显得有点过时. 所有商业版本都是SVR4或4.4BSD的变体, 并且都趋向于遵循某些通用标准, 诸如IEEE的POSIX(Portable Operating Systems based on Unix基于Unix的可移植操作系统)和X/Open的CAE(Common Applications Environment, 公共应用环境). 

现有标准仅仅指定了应用程序编程接口(application programming interfale, API)------也就是说, 指定了用户程序应当运行的一个已定义好的环境. 因此, 这些标准并没有对内核的内部设计施加任何限制. 

为了定义一个通用用户接口, 类Unix内核通常采用相同的设计思想和特征. 在这一点上, Linux和其他的类Unix操作系统是一样的. 因此, 阅读本书并研读Linux内核也有助于你理解其他Unix变体. 

Linux内核2.6版的目标是遵循IEEE POSIX标准. 这意味着在Linux系统下, 很容易编译和运行目前现有的大多数Unix程序, 只需少许或根本无需为源代码打补丁. 此外, Linux包括了现代Unix操作系统的全部特点, 诸如**虚拟存储、虚拟文件系统、轻量级进程、Unix信号量、SVR4进程间通信、支持对称多处理器(Symmetric Multiprocessor, SMP)系统**等. 

Linus Torvalds在写第一个内核的时候, 参考了Unix内幕方面一些经典的书, 比如Maurice Bach的《The Design of the Unix Operating System》(Prentice Hall,.lg86). 实际上, Linux始终对Bach的书(即SVR4)中所描述的Unix基准有些偏爱. 但是, Linux没有拘泥于任何一个特定的变体, 相反, 它尝试采纳了几种不同Ux内核中最好的特征和设计选择. 

Linux与一些著名的商用Unix内核到底如何竞争, [下面给予描述](#subsec1-1): 

+ 单块结构的内核(Monolithic kernel)

  它是一个庞大、复杂的自我完善(do-it-yourself)程序, 由几个逻辑上独立的成分构成. 在这一点上, 它是相当传统的, 大多数商用Uix变体也是单块结构. (一个显著的例外是Apple的Mac Os X和GNU的Hurd操作系统, 它们都是从卡耐基-梅隆大学的Mach演变而来的, 都遵循微内核的方法. )

+ 编译并静态连接的传统Unix内核

  大部分现代操作系统内核可以**动态地装载和卸载部分内核代码**(典型的例子如设备驱动程序), 通常把这部分代码称做模块(module).  Linux对模块的支持是很好的, 因为它能自动按需装载或卸载模块. 在主要的商用Unix变体中, 只有SVR4.2和Solaris内核有类似的特点. 

+ 内核线程

  一些Unix内核, 如Solaris和SVR4.2/MP, 被组织成一组内核线程(kernel thread). 内核线程是一个能被独立调度的执行环境context, 也许它与用户程序有关, 也许仅仅执行一些内核函数. **线程之间的上下文切换比普通进程之间的上下文切换花费的代价要少得多, 因为前者通常在同一个地址空间执行**. Linux以一种十分有限的方式使用内核线程来周期性地执行几个内核函数, 但是, 它们并不代表基本的执行上下文的抽象(这就是下面要讨论的议题). 

+ 多线程应用程序支持

  大多数现代操作系统在某种程度上都支持多线程应用程序, 也就是说, 这些用户程序是根据很多相对独立的执行流来设计的, 而这些执行流之间共享应用程序的大部分数据结构. 一个多线程用户程序由很多轻量级进程(lightweight process, LWP)组成, 这些进程可能对共同的地址空间、共同的物理内存页、共同的打开文件等等进行操作. Linux定义了自己的轻量级进程版本, 这与SVR4、Solaris等其他系统上所使用的类型有所不同. 当LWP的所有商用Unix变体都基于内核线程时, Linux却把轻量级进程当作基本的执行上下文, 通过非标准的clone()系统调用来处理它们. 

+ 枪占式(preemptive)内核

  当采用“可抢占的内核”选项来编译内核时, Linux2.6可以随意交错执行处于特权模式的执行流. 除了Linux2.6, 还有其他一些传统的、通用的Unix系统(如Solaris和Mach3.0)是完全的抢占式内核. SVR4.2/MP通过引入一些固定抢占点(fixedpreemption point)的方法获得有限的抢占能力. 

+ 多处理器支持

  几种Unix内核变体都利用了多处理器系统. Linux2.6支持不同存储模式的对称多处理(SMP), 包括NUMA:系统不仅可以使用多处理器, 而且每个处理器可以毫无区别地处理任何一个任务. 尽管通过一个单独的“大内核锁”使得内核中的少数代码依然串行执行, 但公平地说, Linux 2.6以几乎最优化的方式使用SMP.

+ 文件系统

  Linux标准文件系统呈现出多种风格. 如果你没有特殊需要, 就可以使用普通的**Ext2文件系统**. 如果你想避免系统崩遗后冗长的文件系统检查, 就可以切换到Ext3. 如果你不得不处理很多小文件, ReiserFS文件系统可能就是最好的选择. 除了Ext3和ReiserFS,还可以在Linux中使用另外几个日志文件系统, 这些文件系统包括IBM AIX的日志文件系统(Journaling File System,JFS)和SGI公司IRIX系统上的XFS文件系统. 有了强大的面向对象虚拟文件系统技术(为Solaris和SVR4所采用), 把外部文件系统移植到Linux比移植到其他内核相对要容易. 

+ STREAMS

  尽管现在大部分的Unix内核内包含了SRV4引人的STREAMS I/O子系统, 并且已变成编写设备驱动程序、终端驱动程序及网络协议的首选接口, 但是Liux并没有与此类似的子系统. 

  对Linux的评价充分说明, 与商业化的操作系统相比, Linux已经具备足够的竞争力. 而且, Linux一些独具特色的特点使其成为一种趣味盎然的操作系统. 商业化的Unix内核为了赢得更大的市场份额通常也引入了新特征, 但这些特征本是可有可无, 其稳定性和效率都值得商榷. 事实上, 现代Unix内核有向更臃肿变化的倾向, 而Linux以及其他开放源代码的操作系统不受市场因素的制约, 因此可以根据设计者的想法(主要是Linus Torvalds的想法)自由地演进. 尤其是, 与商用竞争对手相比, Linux有如下优势: 

  + Linux是免费的. 除硬件之外, 你无需任何花费就能安装一套完整的Liux系统. 
  + Linux的所有成分都可以充分地定制. 通过内核编译选项, 你可以选择自己真正需要的特征来定制内核. 而且有了通用公共许可证(GPL),你就可以自由地阅读、修改内核和所有系统程序的源代码.
  + Linux可以运行在低档、便宜的硬件平台上. 你可以用一个4MB内存的旧Intel 80386系统构建网络服务器. 
  + Linux是强大的. 由于充分挖掘了硬件部分的特点, 使得Linux系统速度非常快. Linux的主要目标是效率, 所以, 商用系统的许多设计选择由于有降低性能的隐患而被Linus舍弃, 如STREAMSI/O子系统. 
  + Liux的开发者都是非常出色的程序员. Linux系统非常稳定, 有非常低的故障率和非常少系统维护时间. 
  + Liux内核非常小, 而且紧凑. 我们甚至可以把一个内核映像和一些系统程序放在一张1.4MB的软盘上！据我们所知, 没有一个商用Unix变体能从一张软盘上启动. 
  + Liux与很多通用操作系统高度兼容. Linux可以让你直接安装以下文件系统的所有版本: MS-DOS和MS Windows、SVR4、OS/2、Mac OS X、Solaris、SunOS、NEXTSTEP,还有很多BSD变体等等. 另外, Linux也能对很多网络层进行操作, 这些网络层如以太网[如: 快速以太网和高速(Gbit/s及10Gbit/s)以太网]、光纤分布式数据接口(Fiber Distributed Data Interface, FDDI)、高性能并行接口(High Performance Parallel Interface,HIPPI)、IEEE 802.l1(无线局域网)和IEEE802.15(蓝牙). 通过使用适当的库函数, Liux系统甚至能直接运行为其他操作系统所编写的程序. 例如, Liux能执行为以下操作系统所编写的应用程序: MS-DOS、MS Windows、SVR3及SVR4、4.4BSD、SCO Unix、Xenix,以及其他在Intel80x86平台上运行的操作系统. 
  + Lux有很好的技术支持. 不管你信不信, Linux比任何有版权的操作系统更容易获得补丁和更新！如果你把遇到的难题发给一些新闻组或邮件列表, 经常在几个小时内就会得到回应. 此外, 当新的硬件产品投放市场以后, 其Linux驱动程序通常在几周内就可得到. 与此相反, 硬件厂商仅仅给少数商业操作系统发布设备驱动程序, 通常只有微软一家. 因此, 所有商用Unix变体只能运行在有限的硬件上. 

因为有了数千万台安装Linux的基础, 那些习惯了其他操作系统某些标准特征的用户开始期望Linux也具有相同的特征. 在这种情况下, 对Linux开发者的需求也在不断增加. 值得庆幸的是, 在Linus的密切指导下, Linux始终在不断发展以满足如此众多的需求. 

## 硬件依赖性

Linux试图在硬件无关的源代码与硬件相关的源代码之间保持清晰的界限. 为了做到这点, 在arch和include目录下包含了23个子目录, 以对应Linux所支持的不同硬件平台. 这些平台的标准名字如下: 

+ alpha

  HP的Alpha工作站, 最早属于Digital公司, 后来属于Compag公司, 现在不再生产). 

+ arm, arm26

  基于ARM处理器的计算机(如PDA)和嵌入式设备. 

+ cris

  Axis在它的瘦服务器中使用的“代码精简指令集(Code Reduced Instruction Set)”CPU,用在诸如Web摄像机或开发主板中. 

+ frv

  基于Fujitsu FR-V系列微处理器的嵌入式系统. 

+ h8300

  Hitachi h8/300和h8S的8位和16位RISC微处理器. 

+ i386

  基于80x86微处理器的IBM兼容个人计算机. 

+ ia64

  基于64位Itanium微处理器的工作站. 

+ m32r

  基于Renesas M32R系列微处理器的计算机. 

+ m68k,m68knommu

  基于Motorola MC680x0微处理器的个人计算机. 

+ mips

  基于MIPS微处理器的工作站, 如Silicon Graphics公司销售的那些工作站. 

+ parisc

  基于HP公司HP9000PA-RISC微处理器的工作站. 

+ ppc, ppc64

  基于Motorola-IBM PowerPC32位和64位微处理器的工作站. 

+ s390

  IBM ESA/390及zSeries大型机. 

+ sh,sh64

  基于Hitachi和STMicroelectronics联合开发的SuperH微处理器的嵌人式系统. sparc,sparc64
  基于Sun公司SPARC和64位Ultra SPARC微处理器的工作站. 

+ um

  用户态的Liux一一个允许开发者在用户态下运行内核的虚拟平台. 

+ v850

  集成了基于Harvard体系结构的32位RISC核心的NECV850微控制器. 

+ x86_64

  基于AMD的64位微处理器的工作站, 如Athlon:和Opteron,以及基于Intel的ia32e/
  EM64T64位微处理器的工作站. 

## Linux版本

一直到2.5版本的内核, Liunx都通过简单的编号来区别内核的稳定版和开发版. 每个版本号用三个数字描述, 由圆点分隔. 前两个数字用来表示版本号, 第三个数字表示发布号. 第一位版本号2从1996年开始就没有变过. 第二位版本号表示内核的类型: **如果为偶数, 表示稳定的内核**, 否则, 表示开发中的内核. 

正如内核版本名字所表示的, 稳定版本的内核由Linux的发布者和内核黑客彻底检查过, 一个稳定版的新发布主要用来**纠正用户所报告的错误或者增加新的驱动程序**. 另一方面, 开发版的不同版本之间可能有非常明显的差异. 内核开发者可以自由地采用不同方案进行实验, 但这些实验可能导致内核有很大变化. 用开发版运行应用程序的用户, 当把内核升级到新版时, 也许会遇到一些不那么令人愉快的意外. 

然而, 在Liux内核2.6版的开发过程中, 内核版本的编号方式发生了很大的变化. 主要变化在于**第二个数字已经不再用于表示一个内核是稳定版本还是正在开发的版本**. 因此, 现在内核开发者都在当前的2.6版本中对内核进行大幅改进. 只有在内核开发者必须对内核的重大修改进行测试时, 才会采用一个新的内核分支2.7. 这种2.7的分支要么产生一个新的内核版本, 要么干脆丢弃所修改的部分而回退到2.6版. 

Liux这种新的开发模式意味着两种内核具有相同的版本号, 但却有不同的发布号, 如2.6.10和2.6.11内核就可能在核心部件和基本算法上有很大的差别. 这样一来, 具有新发布号的内核可能潜藏着不稳定性和各种错误. 为了解决这个问题, 内核开发者可能发布带有补丁程序的内核版本, 并且用第四位数字表示带有不同补丁的内核版本. 例如, 在写本段文字时, 最新的稳定内核版本是2.6.11.12.

必须强调的是本书描述的是Linux2.6.11版的内核. 

## 操作系统基本概念

任何计算机系统都包含一个名为操作系统的基本程序集合. 在这个集合里, 最重要的程序称为内核(kernel). 当操作系统启动时, 内核被装入到RAM中, 内核中包含了系统运行所必不可少的很多核心过程(procedure). 其他程序是一些不太重要的实用程序, 尽管这些程序为用户提供了与计算机进行广泛交流的经验(以及用户买计算机要做的所有工作), 但系统根本的样子和能力还是由内核决定. 内核也为系统中所有事情提供了主要功能, 并决定高层软件的很多特性. 因此, 我们将经常使用术语“操作系统”作为“内核”的同义词. 

操作系统必须完成两个主要目标: 

+ 与硬件部分交互, 为包含在硬件平台上的所有低层可编程部件提供服务. 
+ 为运行在计算机系统上的应用程序(即所谓用户程序)提供执行环境. 

一些操作系统允许所有的用户程序都直接与硬件部分进行交互(典型的例子是MS DOS). 与此相反, 类Uix操作系统把与计算机物理组织相关的所有低层细节都对用户运行的程序隐藏起来. 当程序想使用硬件资源时, 必须向操作系统发出一个请求. 内核对这个请求进行评估, 如果允许使用这个资源, 那么, 内核代表应用程序与相关的硬件部分进行交互. 

为了实施这种机制, 现代操作系统依靠特殊的硬件特性来禁止用户程序直接与低层硬件部分进行交互, 或者禁止直接访问任意的物理地址. 特别是, 硬件为CPU引入了至少两种不同的执行模式: **用户程序的非特权模式和内核的特权模式**. Unix把它们分别称为用户态(User Mode)和内核态(Kernel Mode).

我们将在本章剩余部分介绍一些基本概念, 在过去的20多年里, 这些概念推动了Unix、Linux和其他操作系统的设计. 作为Linux用户, 你也许已熟悉了这些概念, 但为了说明这些概念对Linux内核的必要性, 下面试图对其作更深一步的研究. 这些广泛的考虑事实上涉及到全部类Unix系统. 希望本书的其他章节能帮助你理解Linux内核内幕. 

### 多用户系统

多用户系统(multiuser system)就是一台能并发和独立地执行分别属于两个或多个用户的若干应用程序的计算机. “并发”(concurrently)意味着几个应用程序能同时处于活动状态并竞争各种资源, 如CPU、内存、硬盘等等. “独立”(independently)意味着每个应用程序能执行自己的任务, 而无需考虑其他用户的应用程序在干些什么. 当然, 从一个应用程序切换到另一个会使每个应用程序的速度有所减慢, 从而影响用户看到的响应时间. 现代操作系统内核提供的许多复杂特性(我们将在本书中考察这些特性)减少了强加在每个程序上的延迟时间, 给用户提供了尽可能快的响应时间. 

多用户操作系统必须包含以下几个特点: 

+ 核实用户身份的认证机制. 
+ 防止有错误的用户程序防碍其他应用程序在系统中运行的保护机制. 
+ 防止有恶意的用户程序干涉或窥视其他用户的活动的保护机制. 
+ 限制分配给每个用户的资源数的计账机制. 

为了确保能实现这些安全保护机制, 操作系统必须利用与CPU特权模式相关的硬件保护机制, 否则, 用户程序将能直接访问系统电路并克服强加于它的这些限制. Unix是实施系统资源硬件保护的多用户系统. 

### 用户和组

在多用户系统中, 每个用户在机器上都有私用空间；典型地, 他拥有一定数量的磁盘空间来存储文件、接收私人邮件信息等等. 操作系统必须保证用户空间的私有部分仅仅对其拥有者是可见的. 特别是必须能保证, 没有用户能够开发一个用于侵犯其他用户私有空间的系统应用程序. 

所有的用户由一个惟一的数字来标识, 这个数字叫用户标识符(User ID,UID). 通常一个计算机系统只能由有限的人使用. 当其中的某个用户开始一个工作会话时, 操作系统要求输人一个登录名和口令, 如果用户输入的信息无效, 则系统拒绝访问. 因为口令是不公开的, 所以用户的保密性得到了保证. 

为了和其他用户有选择地共享资料, 每个用户是一个或多个用户组的一名成员, 组由唯一的用户组标识符(user group ID)标识. 每个文件也恰好与一个组相对应. 例如, 可以设置这样的访问权限, 拥有文件的用户具有对文件的读写权限, 同组用户仅有只读权限, 而系统中的其他用户没有对文件的任何访问权限. 

任何类Unix操作系统都有一个特殊的用户, 叫做root,即超级用户(super user). 系统管理员必须以root的身份登录, 以便处理用户账号, 完成诸如系统备份、程序升级等维护任务. root用户几乎无所不能, 因为操作系统对她不使用通常的保护机制. 尤其是, root用户能访问系统中的每一个文件, 能干涉每一个正在执行的用户程序的活动. 

### 进程

所有的操作系统都使用一种基本的抽象: 进程(process). 一个进程可以定义为: “程序执行时的一个实例”, 或者一个运行程序的“执行上下文”. 在传统的操作系统中, 一个进程在地址空间(address space)中执行一个单独的指令序列. 地址空间是允许进程引用的内存地址集合. 现代操作系统允许具有多个执行流的进程, 也就是说, 在相同的地址空间可执行多个指令序列. 

多用户系统必须实施一种执行环境, 在这种环境里, 几个进程能并发活动, 并能竞争系统资源(主要是CPU). 允许进程并发活动的系统称为多道程序系统(multi programming)或多处理系统(multi processing). 区分程序和进程是非常重要的: 几个进程能并发地执行同一程序, 而同一个进程能顺序地执行几个程序. 

在单处理器系统上, 只有一个进程能占用CPU, 因此, 在某一时刻只能有一个执行流. 一般来说, CPU的个数总是有限的, 因而只有少数几个进程能同时执行. 操作系统中叫做调度程序(scheduler)的部分决定哪个进程能执行. 一些操作系统只允许有非抢占式(nonpreemptable)进程, 这就意味着, 只有当进程自愿放弃CPU时, 调度程序才被调用. 但是, 多用户系统中的进程必须是抢占式的(preemptable)；操作系统记录下每个进程占有的CPU时间, 并周期性地激活调度程序. 

Unix是具有抢占式进程的多处理操作系统. 即使没有用户登录, 没有程序运行, 也还是有几个系统进程在监视外围设备. 尤其是, 有几个进程在监听系统终端等待用户登录. 当用户输入一个登录名, 监听进程就运行一个程序来验证用户的口令. 如果用户身份得到证实, 那么监听进程就创建另一个进程来执行shell,此时在shell下可以输入命令. 当一个图形化界面被激活时, 有一个进程就运行窗口管理器, 界面上的每个窗口通常都由一个单独的进程来执行. 如果用户创建了一个图形化shell,那么, 一个进程运行图形化窗口, 而第二个进程运行用户可以输入命令的shell. 对每一个用户命令, shell进程都创建执行相应程序的另一个进程. 

类Unix操作系统采用进程/内核模式. 每个进程都自以为它是系统中唯一的进程, 可以独占操作系统所提供的服务. 只要进程发出系统调用(即对内核提出请求, 参见第10章), 硬件就会把特权模式由用户态变成内核态, 然后进程以非常有限的目的开始一个内核过程的执行. 这样, 操作系统在进程的执行上下文中起作用, 以满足进程的请求. 一旦这个请求完全得到满足, 内核过程将迫使硬件返回到用户态, 然后进程从系统调用的下一条指令继续执行. 

### 内核体系结构

如前所述, 大部分Unix内核是单块结构: 每一个内核层都被集成到整个内核程序中, 并代表当前进程在内核态下运行. 相反, 微内核(microkernel)操作系统只需要内核有一个很小的函数集, 通常包括几个同步原语、一个简单的调度程序和进程间通信机制. 运行在微内核之上的几个系统进程实现从前操作系统级实现的功能, 如内存分配程序、设备驱动程序、系统调用处理程序等等. 

尽管关于操作系统的学术研究都是面向微内核的, 但这样的操作系统一般比单块内核的效率低, 因为操作系统不同层次之间显式的消息传递要花费一定的代价. 不过, 微内核操作系统比单块内核有一定的理论优势. 微内核操作系统迫使系统程序员采用模块化的方法, 因为任何操作系统层都是一个相对独立的程序, 这种程序必须通过定义明确而清晰的软件接口与其他层交互. 此外, 已有的微内核操作系统可以很容易地移植到其他的体系结构上, 因为所有与硬件相关的部分都被封装进微内核代码中. 最后, 微内核操作系统比单块内核更加充分地利用了RAM,因为暂且不需要执行的系统进程可以被调出或撒消. 

为了达到微内核理论上的很多优点而又不影响性能, Linux内核提供了模块(module). 模块是一个目标文件, 其代码可以在运行时链接到内核或从内核解除链接. 这种目标代码通常由一组函数组成, 用来实现文件系统、驱动程序或其他内核上层功能. 与微内核操作系统的外层不同, 模块不是作为一个特殊的进程执行的. 相反, 与任何其他静态链接的内核函数一样, 它代表当前进程在内核态下执行. 

使用模块的主要优点包括: 

+ 模块化方法

  因为任何模块都可以在运行时被链接或解除链接, 因此, 系统程序员必须提出良定义的软件接口以访问由模块处理的数据结构. 这使得开发新模块变得容易. 

+ 平台无关性

  即使模块依赖于某些特殊的硬件特点, 但它不依赖于某个固定的硬件平台. 例如, 符合SCSI标准的磁盘驱动程序模块, 在IBM兼容PC与HP的Alpha机上都能很好地工作. 

+ 节省内存使用

  当需要模块功能时, 把它链接到正在运行的内核中, 否则, 将该模块解除链接. 这种机制对于小型嵌入式系统是非常有用的. 

+ 无性能损失

  模块的目标代码一旦被链接到内核, 其作用与静态链接的内核的目标代码完全等价. 因此, 当模块的函数被调用时, 无需显式地进行消息传递. 

## Unix文件系统概述

### 文件

Unix文件是以字节序列组成的信息载体(container),内核不解释文件的内容. 很多编程的库函数实现了更高级的抽象, 例如, 由字段构成的记录以及基于关键字编址的记录. 然而, 这些库中的程序必须依靠内核提供的系统调用. 从用户的观点来看, 文件被组织在一个树结构的命名空间中, 如[图1-1](#fig1-1)所示. 

<img src="https://namebucket.oss-cn-beijing.aliyuncs.com/img/%E5%9B%BE1-1%20%E7%9B%AE%E5%BD%95%E6%A0%91%E7%A4%BA%E4%BE%8B.svg" style="zoom:20%;"/>

<center><a name="fig1-1"></a>图1-1 文件目录树</center>

除了叶节点之外, 树的所有节点都表示目录名. 目录节点包含它下面文件及目录的所有信息. 文件或目录名由除`\`和空字符`\0`之外的任意ASCII字符序列组成. 大多数文件系统对文件名的长度都有限制, 通常不能超过255个字符. 与树的根相对应的目录被称为根目录(root directory). 按照惯例, 它的名字是`/`. 在同一目录中的文件名不能相同, 而在不同目录中的文件名可以相同. 

Unix的每个进程都有一个当前工作目录(参见本章后面的“[进程/内核模式](#sec1-6-1)”一节), 它属于进程执行上下文(execution context),标识出进程所用的当前目录. 为了标识一个特定的文件, 进程使用路径名(path name), 路径名由斜杠及一列指向文件的目录名交替组成. 如果路径名的第一个字符是斜杠, 那么这个路径就是所谓的绝对路径, 因为它的起点是根目录. 否则, 如果第一项是目录名或文件名, 那么这个路径就是所谓的相对路径, 因为它的起点是进程的当前目录. 

当标识文件名时, 也用符号`..`和`.`. 它们分别标识当前工作目录和父目录. 如果当前工作目录是根目录, `..`和`.`就是一致的. 

### 硬链接和软链接

包含在目录中的文件名就是一个文件的硬链接(hard link),或简称链接(Link). 在同一目录或不同的目录中, 同一文件可以有几个链接, 因此对应几个文件名. 

创建<u>硬链接</u>的Unix命令: 

```bash
$ ln P1 P2
# 用来创建一个新的硬链接, 即为由路径P1标识的文件创建一个路径名为P2的硬链接
```

硬链接有两方面的限制: 

+ 不允许用户给目录创建硬链接. 因为这可能把目录树变为环形图, 从而就不可能通过名字定位一个文件. 
+ 只有在同一文件系统中的文件之间才能创建链接. 这带来比较大的限制, 因为现代Unix系统可能包含了多种文件系统, 这些文件系统位于不同的磁盘和根目录或分区, 用户也许无法知道它们之间的物理划分. 

为了克服这些限制, 引入了软链接(soft link)[也称符号链接(symbolic link)]. 符号链接是短文件, 这些文件包含有另一个文件的任意一个路径名. 路径名可以指向位于任意一个文件系统的任意文件或目录, 甚至可以指向一个不存在的文件. 

创建<u>软链接</u>的Unix命令:

```bash
$ ln -s P1 P2
# 创建一个路径名为P2的新软链接, P2指向路径名P1
```

当这个命令执行时, 文件系统抽出P2的目录部分, 并在那个目录下创建一个名为P2的符号链接类型的新项. 这个新文件包含路径名P1. 这样, 任何对P2的引用都可以被自动转换成指向P1的一个引用. 

### 文件类型

Unix文件可以是下列类型之一: 

+ 普通文件(regular file)
+ 目录
+ 符号链接
+ 面向块的设备文件(block-oriented device file)
+ 面向字符的设备文件(character-oriented device file)
+ 管道(pipe)和命名管道(named pipe)(也叫FlFO)
+ 套接字(socket)

前三种文件类型是所有[Unix文件系统](#sec18)的基本类型. 

设备文件与I/O设备以及集成到内核中的设备驱动程序相关. 例如, 当程序访问设备文件时, 它直接访问与那个文件相关的I/O设备(参见[第十三章]((#sec13))).

管道和套接字是用于进程间通信的特殊文件(参见本章后面的[同步和临界区](#sec19)一节以及[第十九章](#sec19)). 

### 文件描述符与索引节点

Unix对文件的内容和描述文件的信息给出了清楚的区分. 除了设备文件和特殊文件系统文件外, 每个文件都由字符序列组成. 文件内容不包含任何控制信息, 如文件长度或文件结束(end-of-file,EOF)符. 
文件系统处理文件需要的所有信息包含在一个名为索引节点(inode)的数据结构中. 每个文件都有自己的索引节点, 文件系统用索引节点来标识文件. 

虽然文件系统及内核函数对索引节点的处理可能随Unix系统的不同有很大的差异, 但它们必须至少提供在POSIX标准中指定的如下属性: 

+ 文件类型(参见前一节)
+ 与文件相关的硬链接个数
+ 以字节为单位的文件长度
+ 设备标识符(即包含文件的设备的标识符)
+ 在文件系统中标识文件的索引节点号
+ 文件拥有者的UID
+ 文件的用户组ID
+ 几个时间戳, 表示索引节点状态改变的时间、最后访问时间及最后修改时间
+ 访问权限和文件模式(参见下一节)

### 访问权限和文件模式

文件的潜在用户分为三种类型：

+ 作为文件所有者的用户
+ 同组用户，不包括所有者
+ 所有剩下的用户（其他）

有三种类型的访问权限---读、写及执行每组用户都有这三种权限。因此，文件访问权限的组合就用九种不同的二进制来标记。还有三种附加的标记，即suid(Set User ID),Sgid(Set Group ID),及sticky用来定义文件的模式。当这些标记应用到可执行文件时有如下含义：

+ suid

  进程执行一个文件时通常保持进程拥有者的UID。然而，如果设置了可执行文件suid的标志位，进程就获得了该文件拥有者的UID.

+ sgid

  进程执行一个文件时保持进程组的用户组ID。然而，如果设置了可执行文件sgid的标志位，进程就获得了该文件用户组的ID.

+ sticky

  设置了st1cky标志位的可执行文件相当于向内核发出一个请求，当程序执行结束以后，依然将它保留在内存。

当文件由一个进程创建时，文件拥有者的ID就是该进程的UID。而其用户组ID可以是进程创建者的ID,也可以是父目录的ID,这取决于父目录sgid标志位的值。

### 文件操作的系统调用

当用户访问一个普通文件或目录文件的内容时，他实际上是访问存储在硬件块设备上的一些数据。从这个意义上说，文件系统是硬盘分区物理组织的用户级视图。因为处于用户态的进程不能直接与低层硬件交互，所以每个实际的文件操作必须在内核态下进行。因此，Unix操作系统定义了几个与文件操作有关的系统调用。

所有Uix内核都对硬件块设备的处理效率给予极大关注，其目的是为了获得非常好的系统整体性能。在后面的章节中，我们将描述Linux与文件操作相关的主题，尤其是讨论内核如何对文件相关的系统调用作出反应。为了理解这些内容，你需要知道如何使用文件操作的主要系统调用。下面对此给予描述。

#### 打开文件

进程只能访问“打开的”文件。为了打开一个文件，进程调用系统调用`fd=open(path,flag,mode)`:

+ path: 表示被打开文件的（相对或绝对）路径。
+ flag: 指定文件打开的方式(例如，读、写、读/写、追加)。它也指定是否应当创建一个不存在的文件。
+ mode: 指定新创建文件的访问权限。

这个系统调用创建一个“打开文件”对象，并返回所谓文件描述符(file descriptor)的标识符。一个打开文件对象包括：

+ 文件操作的一些数据结构，如指定文件打开方式的一组标志，表示文件当前位置的offset字段，从这个位置开始将进行下一个操作（即所谓的文件指针），等等。
+ 进程可以调用的一些内核函数指针。这组允许调用的函数集合由参数flag的值决定。

在这里，我们仅描述一些POSIX语义所指定的一般特性：

+ 文件描述符表示进程与打开文件之间的交互，而打开文件对象包含了与这种交互相关的数据。同一打开文件对象也许由同一个进程中的几个文件描述符标识。
+ 几个进程也许同时打开同一文件。在这种情况下，文件系统给每个文件分配一个单独的打开文件对象以及单独的文件描述符。当这种情况发生时，Unix文件系统对进程在同一文件上发出的I/O操作之间不提供任何形式的同步机制。然而，有几个系统调用，如`flock()`,可用来让进程在整个文件或分文件上对I/O操作实施同步（参见[第十二章](#sec12)）。

为了创建一个新的文件，进程也可以调用`create()`系统调用，它与`open()`非常相似，都是由内核来处理。

#### 访问打开的文件

对普通Unix文件，可以顺序地访问，也可以随机地访问，而对设备文件和命名管道文件，通常只能顺序地访问。在这两种访问方式中，内核把文件指针存放在打开文件对象中，也就是说，当前位置就是下一次进行读或写操作的位置。

顺序访问是文件的默认访问方式，即`read()`和`write()`系统调用总是从文件指针的当前位置开始读或写。为了修改文件指针的值，必须在程序中显式地调用`lseek()`系统调用。当打开文件时，内核让文件指针指向文件的第一个字节(偏移量为0)。

`lseek()`系统调用需要下列参数`newoffset=lseek (fd,offset,whence)`
其参数含义如下：

+ fd: 表示打开文件的文件描述符。
+ offset: 指定一个有符号整数值，用来计算文件指针的新位置。
+ whence: 指定文件指针新位置的计算方式
  + 可以是offset加0，表示文件指针从文件头移动，
  + 也可以是offset加文件指针的当前位置，表示文件指针从当前位置移动，
  + 还可以是offset加文件最后一个字节的位置，表示文件指针从文件末尾开始移动。

`read()`系统调用需要以下参数`nread=read(fd,buf,count)`
其参数含义如下：

+ fd: 表示打开文件的文件描述符。
+ buf: 指定在进程地址空间中缓冲区的地址，所读的数据就放在这个缓冲区。
+ count: 表示所读的字节数。

当处理这样的系统调用时，内核会尝试从拥有文件描述符fd的文件中读count个字节，其起始位置为打开文件的offset字段的当前值。在某些情况下可能遇到文件结束、空管道等等，因此内核无法成功地读出全部count个字节。返回的nread值就是实际所读的字节数。给原来的值加上nread就会更新文件指针。`write()`的参数与`read()`相似。

#### 关闭文件

当进程无需再访问文件的内容时，就调用系统调用`res=close(fd)`
释放与文件描述符fd相对应的打开文件对象。当一个进程终止时，内核会关闭其所有仍然打开着的文件。

#### 更名及删除文件

要重新命名或删除一个文件时，进程不需要打开它。实际上，这样的操作并没有对这个文件的内容起作用，而是对一个或多个目录的内容起作用。例如，系统调用`res=rename(oldpath,newpath)`改变了文件链接的名字，而系统调用`res=unlink (pathname)`减少了文件链接数，删除了相应的目录项。只有当链接数为0时，文件才被真正删除。

## Unix内核概述

Unix内核提供了应用程序可以运行的执行环境。因此，内核必须实现一组服务及相应的接口。应用程序使用这些接口，而且通常不会与硬件资源直接交互。

### 进程/内核模式<a name="sec1-6-1"></a>

如前所述，CPU既可以运行在用户态下，也可以运行在内核态下。实际上，一些CPU可以有两种以上的执行状态。例如，Intel 80x86微处理器有四种不同的执行状态。但是，所有标准的Unix内核都仅仅利用了内核态和用户态。

当一个程序在用户态下执行时，它不能直接访问内核数据结构或内核的程序。然而，当应用程序在内核态下运行时，这些限制不再有效。每种CPU模型都为从用户态到内核态的转换提供了特殊的指令，反之亦然。一个程序执行时，大部分时间都处在用户态下，只有需要内核所提供的服务时才切换到内核态。当内核满足了用户程序的请求后，它让程序又回到用户态下。

进程是动态的实体，在系统内通常只有有限的生存期。创建、撤消及同步现有进程的任务都委托给内核中的一组例程来完成。

内核本身并不是一个进程，而是进程的管理者。进程/内核模式假定：请求内核服务的进程使用所谓系统调用(system call)的特殊编程机制。每个系统调用都设置了一组识别进程请求的参数，然后执行与硬件相关的CPU指令完成从用户态到内核态的转换。

除用户进程之外，Unix系统还包括几个所谓内核线程(kernel thread)的特权进程（被赋予特殊权限的进程），它们具有以下特点：

+ 它们以内核态运行在内核地址空间。
+ 它们不与用户直接交互，因此不需要终端设备。
+ 它们通常在系统启动时创建，然后一直处于活跃状态直到系统关闭。

在单处理器系统中，任何时候只有一个进程在运行，它要么处于用户态，要么处于内核态。如果进程运行在内核态，处理器就执行一些内核例程。[图1-2](#fig1-2)举例说明了用户态与内核态之间的相互转换。处于用户态的进程1发出系统调用之后，进程切换到内核态，系统调用被执行。然后，直到发生定时中断且调度程序在内核态被激活，进程1才恢复在用户态下执行。进程切换发生，进程2在用户态开始执行，直到硬件设备发出中断请求。中断的结果是，进程2切换到内核态并处理中断。

Unix内核做的工作远不止处理系统调用。实际上，可以有几种方式激活内核例程：

+ 进程调用系统调用。
+ 正在执行进程的CPU发出一个异常(exception)信号，异常是一些反常情况，例如一个无效的指令。内核代表产生异常的进程处理异常。
+ 外围设备向CPU发出一个中断(interrupt)信号以通知一个事件的发生，如一个要求注意的请求、一个状态的变化或一个I/O操作已经完成等。每个中断信号都是由内核中的中断处理程序(interrupt handler)来处理的。因为外围设备与CPU异步操作，因此，中断在不可预知的时间发生。
+ 内核线程被执行。因为内核线程运行在内核态，因此必须认为其相应程序是内核的一部分。

### 进程实现

为了让内核管理进程，每个进程由一个进程描述符(process descriptor)表示，这个描述符包含有关进程当前状态的信息。

当内核暂停一个进程的执行时，就把几个相关处理器寄存器的内容保存在进程描述符中。这些寄存器包括：

+ 程序计数器(PC)和栈指针(SP)寄存器
+ 通用寄存器
+ 浮点寄存器
+ 包含CPU状态信息的处理器控制寄存器(处理器状态字，Processor Status Word)
+ 用来跟踪进程对RAM访问的内存管理寄存器

当内核决定恢复执行一个进程时，它用进程描述符中合适的字段来装载CPU寄存器。因为程序计数器中所存的值指向下一条将要执行的指令，所以进程从它停止的地方恢复执行。

当一个进程不在CPU上执行时，它正在等待某一事件。Unix内核可以区分很多等待状态，这些等待状态通常由进程描述符队列实现。每个（可能为空）队列对应一组等待特定事件的进程。

### 可重入内核

所有的Unix内核都是可重入的(reentrant), 这意味着若千个进程可以同时在内核态下执行。当然，在单处理器系统上只有一个进程在真正运行，但是有许多进程可能在等待CPU或某一I/O操作完成的时侯, 在内核态下被阻塞。例如，当内核代表某一进程发出一个读磁盘请求后，就让磁盘控制器处理这个请求并且恢复执行其他进程。当设备满足了读请求时，有一个中断就会通知内核，从而以前的进程可以恢复执行。

提供可重入的一种方式是<u>编写函数</u>，以便这些函数只能修改局部变量，而不能改变全局数据结构，这样的函数叫可重入函数。但是可重入内核不仅仅局限于这样的可重入函数（尽管一些实时内核正是如此实现的）。相反，可重入内核可以包含非重入函数，并且利用锁机制保证一次只有一个进程执行一个非重入函数。

如果一个硬件中断发生，可重入内核能挂起当前正在执行的进程，即使这个进程处于内核态。这种能力是非常重要的，因为这能提高发出中断的设备控制器的吞吐量。一旦设备已发出一个中断，它就一直等待直到CPU应答它为止。如果内核能够快速应答，设备控制器在CPU处理中断时就能执行其他任务。

现在，让我们看一下内核的可重入性及它对内核组织的影响。内核控制路径(kernel control path)表示内核处理系统调用、异常或中断所执行的指令序列。

在最简单的情况下，CPU从第一条指令到最后一条指令顺序地执行内核控制路径。然而，当下述事件之一发生时，CPU交错执行内核控制路径：

+ 运行在用户态下的进程调用一个系统调用，而相应的内核控制路径证实这个请求无法立即得到满足，然后，内核控制路径调用调度程序选择一个新的进程投入运行。结果，进程切换发生。第一个内核控制路径还没完成，而CPU又重新开始执行其他的内核控制路径。在这种情况下，两条控制路径代表两个不同的进程在执行。
+ 当运行一个内核控制路径时，CPU检测到一个异常（例如，访问一个不在RAM中的页）。第一个控制路径被挂起，而CPU开始执行合适的过程。在我们的例子中，这种过程能给进程分配一个新页，并从磁盘读它的内容。当这个过程结束时，第一个控制路径可以恢复执行。在这种情况下，两个控制路径代表同一个进程在执行。
+ 当CPU正在运行一个启用了中断的内核控制路径时，一个硬件中断发生。第一个内核控制路径还没执行完，CPU开始执行另一个内核控制路径来处理这个中断。当这个中断处理程序终止时，第一个内核控制路径恢复。在这种情况下，两个内核控制路径运行在同一进程的可执行上下文中，所花费的系统CPU时间都算给这个进程。然而，中断处理程序无需代表这个进程运行。
+ 在支持抢占式调度的内核中，CPU正在运行，而一个更高优先级的进程加入就绪队列，则中断发生。在这种情况下，第一个内核控制路径还没有执行完，CPU代表高优先级进程又开始执行另一个内核控制路径。只有把内核编译成支持抢占式调度之后，才可能出现这种情况。

### 进程地址空间

每个进程运行在它的私有地址空间。在用户态下运行的进程涉及到私有栈、数据区和代码区。当在内核态运行时，进程访问内核的数据区和代码区，但使用另外的私有栈。

因为内核是可重入的，因此几个内核控制路径（每个都与不同的进程相关）可以轮流执行。在这种情况下，每个内核控制路径都引用它自己的私有内核栈。

尽管看起来每个进程访问一个私有地址空间，但有时进程之间也共享部分地址空间。在一些情况下，这种共享由进程显式地提出；在另外一些情况下，由内核自动完成共享以节约内存。

如果同一个程序（比如说编辑程序）由几个用户同时使用，则这个程序只被装入内存一次，其指令由所有需要它的用户共享。当然，其数据不被共享，因为每个用户将有独立的数据。这种共享的地址空间由内核自动完成以节省内存。

进程间也能共享部分地址空间，以实现一种进程间通信，这就是由System V引入并且已经被Linux支持的“共享内存”技术。

最后，Linux支持mmap（）系统调用，该系统调用允许存放在块设备上的文件或信息的部分映射到进程的部分地址空间。内存映射为正常的读写传送数据方式提供了另一种选择。如果同一文件由几个进程共享，那么共享它的每个进程地址空间都包含有它的内存映射。

### 同步和临界区

实现可重入内核需要利用同步机制：如果内核控制路径对某个内核数据结构进行操作时被挂起，那么，其他的内核控制路径就不应当再对该数据结构进行操作，除非它已被重新设置成一致性(consistent)状态。否则，两个控制路径的交互作用将破坏所存储的信息。

例如，假设全局变量V包含某个系统资源的可用项数。第一个内核控制路径A读这个变量，并且确定仅有一个可用资源项。这时，另一个内核控制路径B被激活，并读同一个变量V, V的值仍为1。因此，B对V减1，并开始用这个资源项。然后，A恢复执行。因为A已经读到V的值，于是它假定自己可以对V减1并获取B已经在使用的这个资源项。结果，V的值变为-1，两个内核控制路径使用相同的资源项有可能导致灾难性的后果。

当某个计算结果取决于如何调度两个或多个进程时，相关代码就是不正确的。我们说存在一种竞争条件(race condition)。

# 内存寻址

> + 80x86微处理器怎样进行芯片级的内存寻址
> + Linux如何利用寻址硬件的
> + 理解分页单元的一般原理, 研究内存寻址技术在其他平台上是如何实现的

操作系统自身不必完全了解物理内存, 如今的微处理器包含的硬件线路使内存管理既高效又健壮，所以编程错误就不会对该程序之外的内存产生非法访问。

## 内存地址

使用内存地址作为访问内存单元内容的一种方式, 在使用80x86微处理器时, 需要区分三种不同的地址:

+ <u>逻辑地址(logial address)</u>

  包含在机器语言指令中用来指定一个操作数或一条指令的地址。这种寻址方式在80x86著名的分段结构中表现得尤为具体，它促使MS-DOS或Windows程序员把程序分成若干段。每一个逻辑地址都由一个段(segment)和偏移量(offset或displacement)组成，偏移量指明了从段开始的地方到实际地址之间的距离。

+ <u>线性地址(linear address)(也称虚拟地址virtual address)</u>

  是一个32位无符号整数，可以用来表示4GB的地址，也就是多达 $2^{32}$ 个内存单元。线性地址通常用十六进制数字表示，值的范围从0x00000000到0xffffffff

+ <u>物理地址(physical address)</u>

  用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示。

内存控制单元(MMU)通过一种称为分段单元(segmentation unit)的硬件电路把一个逻辑地址转换成线性地址，接着，第二个称为分页单元(paging unit)的硬件电路把线性地址转换成一个物理地址(见图2-1)。

在多处理器系统中，所有CPU都共享同一内存，这意味着RAM芯片可以由独立的CPU并发地访问。因为在RAM芯片上的读或写操作必须串行地执行，因此一种所谓内存仲裁器(memory arbiter)的硬件电路插在总线和每个RAM芯片之间。其作用是如果某个RAM芯片空闲，就准予一个CPU访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为单处理器系统中包含一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作[参见第十三章“直接内存访问(DMA)”一节”]。在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。例如，双Pentium在每个芯片的入口维持一个两端口仲裁器，并在试图使用公用总线前请求两个CPU交换同步信息。从编程观点看，因为仲裁器由硬件电路管理，因此它是隐藏的。

# 内存管理

> + 内核怎样给自己分配主存

# 进程地址空间

> + 怎样给进程分配线性地址





